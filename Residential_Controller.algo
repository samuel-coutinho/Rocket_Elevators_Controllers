DEFINE constant number_floors EQUAL 10
DEFINE integer requested_floor
DEFINE number_cages EQUAL 2 
DEFINE cages array[number_cages]
DEFINE cages_direction array[number_cages]
DEFINE cages_button array[number_floors + 1]
DEFINE requested_floor_direction
DEFINE cages_current_floor  array[number_floors + 1]
DEFINE cages_destinations array[number_cages, number_floors + 1]

DEFINE Floor_Button USING floor_number AND requested_direction:
    FLOOR_NUMBER: floor_number,
    REQUESTED_DIRECTION: requested_direction
ENDDEFINE

SET floor_request_button TO INSTANTIATE Floor_Button
IF Floor_Button IS pressed THEN
    SET floor_number TO READ Floor_Button floor_number   
    SET requested_direction TO READ Floor_Button requested_direction
    CALL addFloorQueue WITH floor_number AND requested_direction RETURNING selected_cage
ENDIF

FOR EACH cage IN cages
    IF cage_button IS pressed THEN
        SET requested_floor TO READ cage_button
        SET requested_direction TO READ     
        CALL addCageQueue WITH requested_floor AND cage position
    ENDIF
ENDFOR

CALL doQueue WITH cage1

SEQUENCE addFloorQueue USING floor_number AND floor_direction         
        SET shortest_distance_cage_floor TO number_floors
        SET cage_find TO 0
        
        CALL testCagesInSameDirection WITH floor_direction RETURNING selected_cage AND cage_find
        IF  cage_find IS EQUAL 0 THEN
            CALL testCagesInSameDirection WITH idle RETURNING selected_cage AND cage_find
        ENDIF
        If cage_find IS EQUAL 0 THEN
            CALL tryFindAvailableCage RETURNING selected_cage AND cage_find
        ENDIF
        If cage_find IS EQUAL 1 THEN
            SET cages_destinations[selected_cage][floor_number]
        ENDIF          
ENDSEQUENCE

SEQUENCE testCagesInSameDirection WITH test_direction RETURNING selected_cage AND cage_find
    FOR EACH row IN cages_destinations[row][column]
        IF cages_direction[row] IS EQUAL test_direction THEN
            CALL tryFindAvailableCage RETURNING selected_cage AND cage_find
            IF cage_find IS EQUAL 1 THEN
                RETURN selected_cage AND cage_find
            ELSE RETURN cage_find
            ENDIF
        ENDIF
    ENDFOR
ENDSEQUENCE

SEQUENCE tryFindAvailableCage RETURNING selected_cage AND cage_find
    CALL calcDistanceToNextDestinationFloor WITH cages_direction RETURNING distance_cage_floor
    IF distance_cage_floor IS LESS THAN shortest_distance_cage_floor THEN
        SET shortest_distance_cage_floor TO distance_cage_floor
        SET selected_cage TO cage_number
        SET cage_find TO 1       
    ENDIF
ENDSEQUENCE

SEQUENCE calcDistanceToNextDestinationFloor WITH cages_direction RETURNING distance_cage_floor
    distance_cage_floor IS EQUAL 0
    SET column TO cages_current_floor
    WHILE distance_cage_floor IS EQUAL 0
        INCREMENT column
        IF cages_direction IS up
            IF cages_destinations[row][column] IS NOT EQUAL 0 THEN
                RETURN distance_cage_floor AS diference between cages_destinations[row][column] AND cages_current_floor            
            ENDIF               
        ENDIF
        IF cages_direction IS down
            SUBTRACT 1 FROM column
            IF cages_destinations[row][column] IS NOT EQUAL 0 THEN
                RETURN distance_cage_floor AS diference between cages_current_floor AND cages_destinations[row][column]             
            ENDIF               
        ENDIF
    ENDWHILE
ENDSEQUENCE



SEQUENCE addCageQueue USING requested_floor AND cage_id     
        FOR EACH position in 1 TO 10 FROM least significant to most significant
            IF direction  IS EQUAL up 
                IF floor_number IS EQUAL position THEN
                    SET queue_up(position) TO direction
                ENDIF
            ENDIF
            IF direction  IS EQUAL down 
                IF floor_number IS EQUAL position THEN
                    SET queue_down(position) TO direction
                ENDIF
            ENDIF
        ENDFOR   
ENDSEQUENCE


SEQUENCE doQueue USING cage
   
    IF next_target IS NOT EQUAL 0
        CALL checkNextTtarget WITH cage direction AND cage current_floor RETURNING next_target
        CALL goNextTarget WITH next_target
    ENDIF
    ELSE IF cage direction IS idle
        FOR EACH index in floor_queue FROM cage current_floor to most significant
            IF floor_queue[index] IS EQUAL up OR down
                SET distance TO index MINUS cage current_floor
                 


    
ENDSEQUENCE


SEQUENCE checkNextTtarget USING cage direction AND current_floor
    IF cage direction IS up
        FOR EACH index in floor_queue FROM cage current_floor to most significant
            IF floor_queue[index] IS EQUAL up OR cage id
                SET next_target TO index
            ENDIF
        ENDFOR
    ENDIF
    ELSE cage direction IS down
        FOR EACH index in floor_queue FROM cage current_floor to least significant
            IF floor_queue[index] IS EQUAL down OR cage id
                SET next_target TO index
            ENDIF
        ENDFOR
    ENDIF
    RETURN next_target
ENDSEQUENCE
